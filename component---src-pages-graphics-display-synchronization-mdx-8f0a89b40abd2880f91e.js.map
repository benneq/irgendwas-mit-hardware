{"version":3,"sources":["webpack:///./src/pages/graphics/display-synchronization.mdx"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","src","DoubleBufferingImage","DoubleBufferingVSyncImage","TripleBufferingVSyncImage","RenderAheadImage","VRRImage","isMDXComponent"],"mappings":"wUAUaA,EAAe,CAC1B,MAAS,2BAELC,EAAc,CAClBD,gBAGa,SAASE,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAE5E,4CACA,sLACA,0CACA,8QACA,kZACA,mBAAKC,IAAKC,MACV,sDACA,0bACA,iQACA,+QACA,wUACA,mBAAKD,IAAKE,MACV,sDACA,8VACA,iJACA,yNACA,uMACA,mBAAKF,IAAKG,MACV,wCACA,iIACA,mDACA,+XACA,+hBACA,mBAAKH,IAAKI,MACV,mDACA,6TACA,qDACA,8WACA,6cACA,2JACA,mBAAKJ,IAAKK,MACV,iEACA,+EACA,6EACA,wHACA,oDAiBJT,EAAWU,gBAAiB","file":"component---src-pages-graphics-display-synchronization-mdx-8f0a89b40abd2880f91e.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DoubleBufferingImage from '../../images/graphics/doublebuffering.svg';\nimport DoubleBufferingVSyncImage from '../../images/graphics/doublebufferingvsync.svg';\nimport TripleBufferingVSyncImage from '../../images/graphics/triplebufferingvsync.svg';\nimport RenderAheadImage from '../../images/graphics/renderahead.svg';\nimport VRRImage from '../../images/graphics/vrr.svg';\nexport const _frontmatter = {\n  \"title\": \"Display Synchronisation\"\n};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h4>{`Fixed Refresh Rate`}</h4>\n    <p>{`Bei Monitoren mit Fixed Refresh Rate werden die einzelnen Frames in festen Intervallen dargestellt: Beispielsweise alle 16,67 ms bei 60 Hz Wiederholfrequenz.`}</p>\n    <h5>{`Double Buffering`}</h5>\n    <p>{`Beim Double Buffering werden zwei getrennte Speicherbereiche für jeweils das Rendering (back buffer) und die Bildübertragung zum Monitor (front buffer) genutzt. Nachdem ein Frame fertig gerendert wurde werden die Buffer vertauscht (buffer swap).`}</p>\n    <p>{`In dieser Form des Double Bufferings kann der buffer swap mitten in der Übertragung eines Bildes zum Monitor stattfinden, sodass der obere, bereits übertragene Teil zum alten Frame gehört und der untere Teil zum neuen Frame. Die Folge ist das sogenannte Tearing. Bei entsprechend hohen Frameraten kann das Bild auf dem Monitor auch aus deutlich mehr als 2 Frameteilen bestehen.`}</p>\n    <img src={DoubleBufferingImage} />\n    <h5>{`VSync (mit Double Buffering)`}</h5>\n    <p>{`Um Tearing zu vermeiden, wird bei der Verwendung von VSync der Buffertausch zusätzlich so lange verzögert bis der Inhalt des front buffers vollständig zum Monitor übertragen wurde. D.h. die Buffer werden erst getauscht wenn sowohl die Grafikkarte den Frame fertig gerendert hat, als auch der Monitor bereit für das nächste Bild ist. Dadurch wird die maximale Framerate auf die Wiederholfrequnz des Monitors limitiert.`}</p>\n    <p>{`Es entsteht eine zusätzliche Verzögerung bei der Bildübertragung, weil das frisch gerenderte Bild nicht sofort dargestellt werden kann, sondern auf den Monitor warten muss. Diese Zeitspanne trägt zur Vergrößerung des input lags bei.`}</p>\n    <p>{`Außerdem kann die Framerate halbiert werden, wenn das Rendering des nächsten Frames nur minimal länger dauert als das Synchronisationsintervall, weil dann bereits wieder die Bildübertragung zum Monitor angestoßen wurde und abgewartet werden muss.`}</p>\n    <p>{`Bei ungleichmäßigen Frameraten unterhalb der Wiederholfrequenz des Monitors kann sogenanntes Stuttering entstehen, indem die Frames in ungleichmäßigen Abständen teilweise mehrfach ausgegeben werden: Die Framerate auf dem Monitor springt dann zwischen der vollen und halben Wiederholfrequenz hin und her.`}</p>\n    <img src={DoubleBufferingVSyncImage} />\n    <h5>{`Triple Buffering (mit VSync)`}</h5>\n    <p>{`Beim Triple Buffering wird ein zweiter back buffer verwendet, um die Vorteile von Double Buffering und VSync zu vereinen. So wird die Grafikkarte nicht mehr durch die Wiederholfrequenz des Monitors in der Framerate limitiert, während gleichzeitig immer das aktuellste fertige Bild für die Übertragung zum Monitor bereitsteht.`}</p>\n    <p>{`Man erhält also ein vergleichbar niedriges input lag wie beim Double Buffering ohne VSync und gleichzeitig kein Tearing.`}</p>\n    <p>{`(Die Framerate kann von externen Tools nicht korrekt ausgelesen werden, da diese nur den front buffer swap zählen, welcher weiterhin synchron mit der Wiederholfrequnz des Monitors stattfindet)`}</p>\n    <p>{`(In manchen Spielen und Grafikbibliotheken wird fälschlicherweise Render Ahead als Triple Buffering bezeichnet, was zum schlechten Image von echtem Triple Buffering beiträgt)`}</p>\n    <img src={TripleBufferingVSyncImage} />\n    <h5>{`Quad Buffering`}</h5>\n    <p>{`Diese Technik wird bei stereoskopischen Ausgaben benutzt, und verwendet Double Buffering für jedes Auge.`}</p>\n    <h5>{`Render Ahead (flip queue)`}</h5>\n    <p>{`Beim Render Ahead werden Frames in einer Warteschlange (render ahead queue) vorberechnet und dann erzwungen hintereinander dargestellt. Das kann zu einer gleichmäßigeren Framerate führen, indem Performancelöcher mit den Frames aus der Warteschlange aufgefüllt werden. Aber je nach Länge und Füllstand der Warteschlange, kann ein erhöhtes input lag entstehen.`}</p>\n    <p>{`Manche Entwickler benutzen Render Ahead mit insgesamt drei Buffern und bezeichnen es fälschlicherweise als Triple Buffering. Diese Technik verhält sich allerdings nur wie Triple Buffering solange die gerenderte Framerate unterhalb der Wiederholfrequnz liegt, weil in diesem Fall die Warteschlange schneller geleert als gefüllt wird. Sobald die Framerate darüber liegt erhält man ein erhöhtes input lag, weil die alten Frames aus der Warteschlange dargestellt werden, obwohl bereits aktuellere Frames eingereiht wurden.`}</p>\n    <img src={RenderAheadImage} />\n    <h5>{`Fast Sync / Enhanced Sync`}</h5>\n    <p>{`Diese Technolgien werden als moderne Alternativen zu VSync gehandelt. Dabei wird oberhalb der Wiederholfrequenz des Monitors Triple Buffering mit VSync verwendet und unterhalb der Wiederholfrequenz wird VSync deaktiviert, wodurch Stuttering reduziert wird, aber Tearing wieder auftreten kann.`}</p>\n    <h4>{`Variable Refresh Rate (VRR)`}</h4>\n    <p>{`Bei Variable Refresh Rate Monitoren kann die Wiederholfrequenz kontinuierlich und stufenlos innerhalb eines bestimmten Bereichs (VRR range) angepasst werden. Dadurch können die fertig gerenderten Frames ohne Verzögerung zum Monitor übertragen werden, wodurch Tearing und Stuttering vermieden und das input lag auf ein Minimum reduziert wird.`}</p>\n    <p>{`Das funktioniert aber nur solange die Framerate sich innerhalb der VRR range befindet. Außerhalb dieses Bereichs ist man wieder auf die Möglichkeiten von Fixed Refresh Rate Monitoren beschränkt. Daher ist es ratsam die Framerate durch Anpassung der Renderauflösung und -qualität so einzustellen, dass die VRR Range nicht verlassen wird. Zusätzlich kann ein Framelimiter verwendet werden, damit die obere Grenze nicht überschritten wird.`}</p>\n    <p>{`Diese Technologie wird auch in mobilen Geräten verwendet, um Energie zu sparen, indem die Wiederholfrequenz temporär gesenkt wird.`}</p>\n    <img src={VRRImage} />\n    <h5>{`G-Sync / FreeSync / Adaptive-Sync / VRR`}</h5>\n    <p>{`Adaptive-Sync ist Teil des DisplayPort 1.2a Standards.`}</p>\n    <p>{`FreeSync ist AMDs Implementierung von Adaptive-Sync.`}</p>\n    <p>{`G-Sync Desktop Monitore benötigen ein G-Sync Modul. In Notebooks nutzt G-Sync den eDP Standard.`}</p>\n    <p>{`VVR ist Teil von HDMI 2.1.`}</p>\n    {\n      /* https://www.anandtech.com/show/2794 */\n    }\n    {\n      /* https://www.anandtech.com/show/11664/amd-radeon-software-crimson-relive-edition-1772/6 */\n    }\n    {\n      /* https://www.youtube.com/watch?v=bMwY_dlZYiM */\n    }\n    {\n      /* https://en.wikipedia.org/wiki/Variable_refresh_r */\n    }\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}